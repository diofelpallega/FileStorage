%% telnet 203.177.109.10 9000
%%
%% A simple chat server created for CSc 102
-module(talker).
-export([start/0, connect/2, recv_loop/4]).

% you can change the ff:
-define(SERVER_NAME,"ThousandSunny Go").
-define(LISTEN_PORT,9000).
% Leave this alone!
-define(TCP_OPTS,[binary,{packet,raw},{nodelay,true},{reuseaddr,true},{active,once}]).

%% start/0 is the main function to call
start() ->
    % start up the service and error out if we cannot
    case gen_tcp:listen(?LISTEN_PORT, ?TCP_OPTS) of
		% we are able to setup a listening socket, successfully
        {ok, Listen} ->
		     
		    % setup our user manager process (note that this is a separate module; see working directory)
			UserManagerPid = usermanager:new(),
			% spawn the first (listener) process that will check the listening socket for an incoming connection
			spawn(?MODULE,connect,[Listen,UserManagerPid]),
			% display something on the Erlang shell
            io:fwrite(?SERVER_NAME ++ " started on ~p.~n", [erlang:localtime()]),
			thousandSunnyBot:stupid();
		 
		% we are not able to setup a listening socket :(
		Error ->
			% display error on the Erlang shell
            io:fwrite("Error: ~p.~n", [Error])
    end.

	
%% connect/2 is the function to spawn (as the listener processs)
%% to check for an incoming connection and handle it 
connect(Listen,UserManagerPid) ->
	% wait here for an incoming connection from the Listen'ing socket
	% and then continue after accept'ing it 
    {ok, Socket} = gen_tcp:accept(Listen),
	% once accepted, set some TCP options
    inet:setopts(Socket,?TCP_OPTS),

	% at this point, this listener process becomes the accept process
	
    % so kick off another listener process to handle connections concurrently.
	% Remember that the first connect/2 (listener) process we spawned at start/0
	% is handling the very first incoming connection. We have to spawn another 
	% listener process to handle a new connection
    spawn(fun() -> connect(Listen,UserManagerPid) end),

	% For this accept'ed connection, setup a new username (i.e., call it "GuessN",
	% where N is a number which starts at 1 and is then incremented for every 
	% new user) with its corresponding Socket; the new user's name is returned 
	% in SocketOwner
	{ok,SocketOwner} = usermanager:new_user(UserManagerPid,Socket),
	% greet this new client,
	usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\rWelcome to  " ++ ?SERVER_NAME ++ "!\n\r"),
	usermanager:say_to_user(UserManagerPid,SocketOwner,"This is being built incrementally by the ERLANG Pirates of MSU-IIT.\n\rSo check back again soon for new .commands, gimmicks and whatnot.\n\rEnjoy!\n\r"),
	% display help,
	usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\rType .quit to exit.\n\r"),
	% tell everybody that this client is now online,
	usermanager:say_to_all(UserManagerPid,"\n\r" ++ SocketOwner ++ " is now online.\n\r"),
	% display the chat prompt (e.g., "Guess1>")
	usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\r" ++ SocketOwner ++ "> "),
	% now, handle this client's messages thru recv_loop/4 until it disconnects
    recv_loop(UserManagerPid,Socket,SocketOwner,[]),
	% once the client has disconnected, we have to close its socket
    gen_tcp:close(Socket),
	% then delete it from our user list
	{ok,deleted} = usermanager:del_user(UserManagerPid,Socket),
	% and finally, inform the rest of the online users that the client
	% has gone offline
	usermanager:say_to_all(UserManagerPid,"\n\r" ++ SocketOwner ++ " is now offline.\n\r").

	
%% recv_loop/4 is the function for handling the connected client's messages	
recv_loop(UserManagerPid,Socket,SocketOwner,DataReceivedSoFar) ->
    % reset the socket for flow control
    inet:setopts(Socket, [{active, once}]),

	% now wait for some data coming from the Socket
    receive
        % do something with the data you receive
        {tcp,Socket,Data} ->
		    % see if the CarriageReturn and NewLine characters can now be found in the data
			% these two characters are generated by telnet whenever the Enter key is pressed
			CRNLPos = binary:match(Data,<<"\r\n">>),
			if
				% CRNL characters found! So, it's time to process the data
				CRNLPos =/= nomatch ->
					% remove CRNL from Data, we don't need them!
					Data1 = binary:split(Data,<<"\r\n">>,[trim]),
					% append Data to DataReceivedSoFar,
					DataReceivedSoFar1 = DataReceivedSoFar ++ Data1,
					% convert it to one whole binary data,
					BinData = binary:list_to_bin(DataReceivedSoFar1),
					% and then into a string, for easy manipulation below
					StrData = binary:bin_to_list(BinData),
					% also, get the string data's length
			         NewStrt =  lists:flatten(StrData),
					% If the data contains a dot(.) and it is the first character, then it's a command...
					IsCmd = string:chr(StrData,$.) == 1,
					if
						% Is it a command?
						IsCmd ->
							% break down the data into a command and its parameters
						    CmdLine = string:tokens(StrData," "),
							% extract the command first
							[Cmd|Params] = CmdLine,
							% and then see if what command is it?
						 
							 
							case Cmd of
							    ".lol" ->
									NumParams = length(Params),
									if
										NumParams == 0 ->
											% inform the client of the error encountered while changing its name
											usermanager:say_to_all(UserManagerPid,"\n\r" ++ SocketOwner ++ " laughs out loud.\n\r"),
											% display the chat prompt
											usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\r" ++ SocketOwner ++ "> "),
											% and then loop with the same name and get a new set of data from the client
											recv_loop(UserManagerPid,Socket,SocketOwner,[]);
										true ->
											% inform the client of the error encountered while changing its name
											usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\rUsage: .lol\n\r"),
											% display the chat prompt
											usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\r" ++ SocketOwner ++ "> "),
											% and then loop with the same name and get a new set of data from the client
											recv_loop(UserManagerPid,Socket,SocketOwner,[])		
									end;
								".name" ->
									% get the number of parameters to the command .name
									NumParams = length(Params),
									if
										% see if the client has passed exactly 1 argument to the command .name
										NumParams == 1 -> 
											% extract the new name from the list of parameters
											[NewName|_] = Params,
											% now, try changing the name of the client to NewName
											{Stat,StatMsg} = usermanager:mod_user(UserManagerPid,Socket,NewName),
											if
												% see if we have successfully changed the name of this client
												Stat == ok ->
													% inform everybody that this client has changed its name; the new name is returned in StatMsg
													usermanager:say_to_all(UserManagerPid,"\n\r" ++ SocketOwner ++ " is now known as " ++ StatMsg ++ ".\n\r"),
													% display the chat prompt
													usermanager:say_to_user(UserManagerPid,NewName,"\n\r" ++ NewName ++ "> "),
													% and then loop with the new name and get a new set of data from the client
													recv_loop(UserManagerPid,Socket,NewName,[]);
												% there was an error while changing the name of this client; error is returned in StatMsg
												true ->
													% inform the client of the error encountered while changing its name
													usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\rError: " ++ atom_to_list(StatMsg) ++ "\n\r"),
													% display the chat prompt
													usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\r" ++ SocketOwner ++ "> "),
													% and then loop with the same name and get a new set of data from the client
													recv_loop(UserManagerPid,Socket,SocketOwner,[])
											end;
										% number of parameters to .name is incorrect!
										true ->
											% inform the user of the syntax of the .name command
											usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\rError: .name <new name>\n\r"),
											% display the chat prompt
											usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\r" ++ SocketOwner ++ "> "),
											% and then loop with the same name and get a new set of data from the client
											recv_loop(UserManagerPid,Socket,SocketOwner,[])											
										end;	
								".quit" ->
									% tell this client "goodbye" and NEVER LOOP again!
									usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\rBye.\n\r");
								% we don't know how to interpret the command issued, so error out!
								Other ->
									% tell this client that the command it issued is unknown
									usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\rError: unknown command -> " ++ Other ++ "\n\r"),
									% display the chat prompt
									usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\r" ++ SocketOwner ++ "> "),
									% and then loop to get a new set of data from the client
									recv_loop(UserManagerPid,Socket,SocketOwner,[])
							end;
						% data received is not a command, so just broadcast it!
						true ->
							 
							 MESSAGE = thousandSunnyBot:send(NewStrt) ,
							 usermanager:say_to_all(UserManagerPid,"\n\r" ++ MESSAGE ++ "\n\r"),
							 usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\r"++ SocketOwner ++ ">"),
							 recv_loop(UserManagerPid,Socket,SocketOwner,[]),
							 
							% display the chat prompt							
							usermanager:say_to_user(UserManagerPid,SocketOwner,"\n\r" ++ SocketOwner ++ "> "),
							% and then loop to get a new set of data from the client
							recv_loop(UserManagerPid,Socket,SocketOwner,[])
					end;
				% CRNL characters NOT yet found, so continue accumulating the data
				true ->
					% this is for debugging purposes only, so you will be able to see
					% the data received by our chat server
					io:format("~p ~p ~p~n", [inet:peername(Socket), erlang:localtime(), Data]),
					% just append Data to DataReceivedSoFar and then loop to get the rest of the data from the client
					recv_loop(UserManagerPid,Socket,SocketOwner,DataReceivedSoFar ++ [Data])
			end;
		% exit loop if the client disconnects
		{tcp_closed,Socket} ->
			% display something on the Erlang shell
			io:fwrite("Client disconnected on ~p.~n", [erlang:localtime()])
	end.